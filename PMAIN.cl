(defvar *usage* "Usage: %T [options...] C-source [output]\n\noptions:\n-w		Do not print any warnings.\n-W 		Print all warnings.\n-g		Emit infomation for debugger.\n-gp offset      Geven gp offset in hexa decimal.\n-byteop		Use byte operation for byte data.\n-uchar		Assume `char' and string element types are unsigned.\n-ucharbool	Boolean type is implemented by unsigned char.\n-ucharenum	Enumulation type is implemented by unsigned char.\n-ucharswitch	Switch selector/case type is implemented by unsigned char.\n-no-uniqstrings	Same string is allocated only onece unless specify this.\n-usefulenum	Enumulation type is treated it's implementation type.\n-mmodel name	Select default memory model.\n-sjis		String includes sjis-hankaku-kana code.\n-load-ld ldfile	Loading ld file.\n-load file	Universal option.\n-eval form      Universal option.\n")

(defun main (args)
    (setq *debug* nil *notify-gc* nil)
    (cond ((= (length args) 1) (xerror *usage* (car args))) (t (setq args (cdr args))
        (let ((debuginfo nil) srcf objf a room)
            (while (setq a (pop args))
                (if (= (sref a 0) 45) (case a 
                    ("-debug" (setq *debug* '(trace fold-const)))
                    ("-notify-gc" (setq *notify-gc* t))
                    ("-w" (setq *nowarning* t))
                    ("-W" (ld-set-all-warnings))
                    ("-g" (setq debuginfo t))
                    ("-gp" (setq *ld-gp-offset* (read-tree (format nil "#x%s" (pop args)))))
                    ("-byteop" (setq (cadr (assq 'char *ld-arith-types*)) 'char (cadr (assq 'uchar *ld-arith-types*)) 'uchar))
                    ("-uchar" (setq (cdr (assq 'char *ld-atomic-type-syntax*)) '((signed char)) (cdr (assq 'uchar *ld-atomic-type-syntax*)) '((char) (unsigned char)) *ld-string-element-type* 'uchar))
                    ("-ucharbool" (setq *ld-bool-type* 'uchar))
                    ("-ucharenum" (setq *ld-enum-type* 'uchar))
                    ("-ucharswitch" (setq *ld-switch-type* 'uchar))
                    ("-no-uniqstrings" (setq *ld-string-uniquize* nil))
                    ("-usefulenum" (setq *ld-pedantic-enum* nil))
                    ("-pedanticenum" (setq *ld-pedantic-enum* t))
                    ("-mmodel" (select-mmodel (pop args)))
                    ("-sjis" (setq *ld-sjis-string-p* t))
                    ("-load" (load (pop args)))
                    ("-load-ld" (load-ld (pop args)))
                    ("-eval" (eval (read-tree (pop args))))
                    ("-room" (setq room t))
                    (t (xerror "%T : No such option\n" a)))

                    (cond ((null srcf) (setq srcf a) (unless (file-exists-p srcf) (xerror "%s: No such file.\n" srcf)))
                        ((null objf) (setq objf a) (when (equal srcf objf) (xerror "output is input.\n")))
                        (t (xerror "too many argument.\n")))))

            (unless srcf (xerror "Missing C-source file.\n"))

        (let ((excode (cparse srcf objf debuginfo))) (when room (room t))
            (exit (if (zerop excode) 0 1)))
))))

(defun select-mmodel (name)
    (case name
        ("small" (setq *ld-default-data-pointer-type* 'near-address *ld-default-function-pointer-type* 'near-address))
        ("medium" (setq *ld-default-data-pointer-type* 'near-address *ld-default-function-pointer-type* 'far-address))
        ("compact" (setq *ld-default-data-pointer-type* 'far-address *ld-default-function-pointer-type* 'near-address))
        ("large" (setq *ld-default-data-pointer-type* 'far-address *ld-default-function-pointer-type* 'far-address))
        ("huge" (setq *ld-default-data-pointer-type* 'huge-address *ld-default-function-pointer-type* 'far-address))
        (t (xerror "%T : No such memory model name.\n" name))))

(setq *stderror* *stdoutput*)
